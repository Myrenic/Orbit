---
version: '3'

tasks:

  # ------------------------
  # Basic checks
  # ------------------------
  ensure_env:
    cmds:
      - |
        set -euo pipefail
        missing=()
        for v in BW_ORGANIZATION_ID BW_PROJECT_ID BW_TOKEN; do
          # portable indirect expansion: use eval
          eval "val=\${${v}:-}"
          if [ -z "${val}" ]; then
            missing+=("$v")
          fi
        done
        if [ ${#missing[@]} -ne 0 ]; then
          echo "Missing required env vars: ${missing[*]}" >&2
          exit 1
        fi

  check_tools:
    cmds:
      - |
        set -euo pipefail
        need=(git terraform kubectl kustomize argocd)
        miss=()
        for cmd in "${need[@]}"; do
          if ! command -v "$cmd" >/dev/null 2>&1; then
            miss+=("$cmd")
          fi
        done
        if [ ${#miss[@]} -ne 0 ]; then
          echo "Missing required CLI tools: ${miss[*]}" >&2
          exit 1
        fi
  pre-checks:
    desc: Check environment variables and required CLIs
    cmds:
      - task ensure_env
      - task check_tools

  check-env:
    desc: Ensure required environment variables are set (including GIT_TOKEN)
    cmds:
      - |
        set -euo pipefail
        missing=()
        for v in BW_ORGANIZATION_ID BW_PROJECT_ID BW_TOKEN GIT_TOKEN; do
          eval "val=\${${v}:-}"
          if [ -z "${val}" ]; then
            missing+=("$v")
          fi
        done
        if [ ${#missing[@]} -ne 0 ]; then
          echo "Missing required env vars: ${missing[*]}" >&2
          exit 1
        fi

  check-cluster:
    desc: Check Kubernetes cluster health
    cmds:
      - kubectl cluster-info
      - kubectl get nodes --no-headers
      - kubectl get pods -A --no-headers | wc -l | xargs echo "Total pods:"

  # ------------------------
  # CRDs and controllers
  # ------------------------
  crds:
    desc: Install 'crds'
    cmds:
      - kustomize build apps/platform/crds | kubectl apply -f -
      - kubectl rollout status deployment -l app.kubernetes.io/component=crds -n default \
        || echo "No CRDs deployment to wait for"

  cert-manager:
    desc: Install 'cert-manager'
    cmds:
      - kustomize build --enable-helm apps/platform/cert-manager | kubectl apply -f -
      - kubectl rollout status deployment -l app.kubernetes.io/instance=cert-manager -n cert-manager

  external-secrets:
    desc: Execute Taskfile in 'external-secrets'
    dir: apps/platform/external-secrets/base/
    cmds:
      - task all
      - kubectl rollout status deployment -l app.kubernetes.io/instance=external-secrets -n external-secrets

  argocd:
    desc: Install 'argocd'
    cmds:
      - kustomize build apps/platform/argocd/base --enable-helm | kubectl apply -f -
      - kubectl apply -f apps/platform/argocd/base/ExternalSecret.yaml
      - kubectl rollout status deployment -l app.kubernetes.io/part-of=argocd -n argocd

  argocd-defaults:
    desc: Add 'argocd' defaults
    cmds:
      - kustomize build apps/platform/defaults/base --enable-helm | kubectl apply -f -
      - kubectl rollout status deployment -l app.kubernetes.io/part-of=argocd -n argocd \
        || echo "No new deployments for projects"

  password-argocd:
    desc: Change 'argocd' default password
    cmds:
      - |
        nohup kubectl port-forward -n argocd svc/argocd-server 8080:80 --address 0.0.0.0 \
          > /dev/null 2>&1 &
      - |
        # wait for port-forward to be ready
        for i in $(seq 1 10); do
          if curl -sS --fail http://localhost:8080/ >/dev/null 2>&1; then
            break
          fi
          sleep 1
        done
      - |
        argocd login localhost:8080 --insecure --username admin \
          --password $(kubectl -n argocd get secret argocd-initial-admin-secret -o \
          jsonpath="{.data.password}" | base64 -d)
      - |
        argocd account update-password --insecure --account admin \
          --current-password $(kubectl -n argocd get secret argocd-initial-admin-secret -o \
          jsonpath="{.data.password}" | base64 -d) \
          --new-password $(kubectl -n argocd get secret argocd-admin-password -o \
          jsonpath="{.data.secretValue}" | base64 -d)
      - |
        pkill -f "kubectl port-forward"

  # ------------------------
  # Orchestration
  # ------------------------
  bootstrap:
    desc: Full bootstrap sequence (pre-checks + infra + apps)
    cmds:
      - task pre-checks
      - task crds
      - task cert-manager
      - task external-secrets
      - task argocd
      - task argocd-defaults
      - task password-argocd

  # ------------------------
  # Logs / Utilities
  # ------------------------
  argo-port-fw:
    aliases: [fw]
    desc: Port-forward ArgoCD server to localhost:8080
    cmds:
      - kubectl port-forward -n argocd svc/argocd-server 8080:80 --address 0.0.0.0

  lint-issues:
    aliases: [lint]
    desc: Check for lint issues in git tracked files
    cmds:
      - git ls-files '*.yml' '*.yaml' | xargs yamllint

  fix-argocd-revisions:
    aliases: [rev]
    desc: Interactively set all ApplicationSet revisions and targetRevisions to a chosen branch
    cmds:
      - |
        set -euo pipefail

        # Ensure we are in the repo root
        if [ ! -d ".git" ]; then
          echo "Error: Taskfile must be run from the root of the git repository." >&2
          exit 1
        fi

        # Fetch all remote branches
        git fetch --all --prune

        # List branches for selection
        branches=($(git branch -r | sed 's|origin/||' | grep -v HEAD | sort -u))
        echo "Available branches:"
        for i in "${!branches[@]}"; do
          printf "  [%d] %s\n" "$i" "${branches[$i]}"
        done

        # Prompt user to pick branch with validation
        while true; do
          read -rp "Select branch by number: " branch_index
          if [[ "$branch_index" =~ ^[0-9]+$ ]] && [ "$branch_index" -ge 0 ] && [ "$branch_index" -lt "${#branches[@]}" ]; then
            branch="${branches[$branch_index]}"
            break
          else
            echo "Invalid selection, try again."
          fi
        done
        echo "Selected branch: $branch"

        files=$(find ./projects ./apps/platform/defaults/base -type f \( -name '*.yaml' -o -name '*.yml' \) -exec grep -l "apiVersion: argoproj.io/v1alpha1" {} + | while read file; do
          if grep -q "    targetRevision:" "$file"; then
            echo "$file"
          fi
        done)
        
        if [ -z "$files" ]; then
          echo "No ApplicationSet YAML files found."
          exit 0
        fi

        # Replace targetRevision and revision values
        for f in $files; do
          echo "Updating $f ..."
          sed -i -E \
            -e "s|(targetRevision:).*|\1 \"$branch\"|" \
            -e "s|(revision:).*|\1 \"$branch\"|" \
            "$f"
        done
        echo "All ApplicationSets updated to branch: $branch"

  # ------------------------
  # Infrastructure (terraform)
  # ------------------------
  terraform-status:
    aliases: [status]
    desc: Run terraform plan (dry-run)
    cmds:
      - terraform -chdir=infrastructure/helios status
  
  terraform-plan:
    aliases: [plan]
    desc: Run terraform plan (dry-run)
    cmds:
      - >
        terraform -chdir=infrastructure/helios plan &
        wait
        
  terraform-apply:
    aliases: [apply]
    desc: Apply terraform changes
    cmds:
      - >
        terraform -chdir=infrastructure/helios apply -auto-approve &
        wait
        
  terraform-destroy:
    aliases: [destroy]
    desc: Destroy terraform infra
    cmds:
      - >
        terraform -chdir=infrastructure/helios destroy -auto-approve &
        wait

  terraform-import:
    aliases: [import]
    desc: Destroy terraform infra
    cmds:
      - terraform -chdir=infrastructure/helios output -raw kubeconfig > ~/.kube/config
      - terraform -chdir=infrastructure/helios output -raw talosconfig > ~/.talos/config

  terraform-reset:
    aliases: [reset]
    desc: Rebuild infra (destroy + apply)
    cmds:
      - task terraform-destroy
      - task terraform-apply
      - task terraform-import
